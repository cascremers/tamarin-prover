theory CSF11_RunningExample begin

// Function signature and definition of the equational theory E

functions: adec/2, aenc/2, fst/1, h/1, pair/2, pk/1, sign/2, snd/1,
           true/0, verify/3
equations:
    adec(aenc(x.1, pk(x.2)), x.2) = x.1,
    fst(<x.1, x.2>) = x.1,
    snd(<x.1, x.2>) = x.2,
    verify(sign(x.1, x.2), x.1, pk(x.2)) = true()

text{* Running example from:

Stephanie Delaune, Steve Kremer, Mark D. Ryan, Graham Steel, "Formal Analysis
of Protocols Based on TPM State Registers," csf, pp.66-80, 2011 IEEE 24th
Computer Security Foundations Symposium, 2011.

Modeler: Simon Meier
Date:    June 2012
Status:  Working

*}

rule (modulo E) PCR_Init:
   [ Fr( ~aik ) ]
  --[ PCR_Init( 'pcr0', ~aik ), UniqueInit( ) ]->
   [ PCR( 'pcr0' ), !AIK( ~aik ), Out( pk(~aik) ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) PCR_Extend:
   [ PCR( x ), In( y ) ]
  --[ PCR_Extend( x, y, h(<x, y>) ) ]->
   [ PCR( h(<x, y>) ) ]

  // loop breaker: [0]
  /* has exactly the trivial AC variant */

rule (modulo E) PCR_CertKey:
   [ !AIK( aik ), !KeyTable( x, sk ) ]
  --[ PCR_CertKey_Inst( x ) ]->
   [ Out( sign(<'certkey', x, pk(sk)>, aik) ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) PCR_Unbind:
   [ PCR( x ), !KeyTable( x, sk ), In( aenc(m, pk(sk)) ) ]
  --[ PCR_Unbind( x, sk, m ) ]->
   [ PCR( x ), Out( m ) ]

  // loop breaker: [0]
  /* has exactly the trivial AC variant */

rule (modulo E) Alice_Init:
   [
   Fr( ~s0 ), Fr( ~s1 ), !AIK( aik ), In( sign(<'certkey', x0, pk0>, aik) ),
   In( sign(<'certkey', x1, pk1>, aik) )
   ]
  --[ Ineq( x0, x1 ), Secrets( ~s0, ~s1 ) ]->
   [ Out( aenc(~s0, pk0) ), Out( aenc(~s1, pk1) ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) MkKey:
   [ Fr( ~ska ) ] --> [ !KeyTable( h(<'pcr0', $a>), ~ska ) ]

  /* has exactly the trivial AC variant */

lemma types [typing]:
  all-traces
  "∀ m d1 d2 #i.
    (PCR_Unbind( d1, d2, m ) @ #i) ⇒
    (((∃ #j. (!KU( m ) @ #j) ∧ (#j < #i)) ∨ (∃ s #j. Secrets( m, s ) @ #j)) ∨
     (∃ s #j. Secrets( s, m ) @ #j))"
/*
guarded formula characterizing all counter-examples:
"∃ m d1 d2 #i.
  (PCR_Unbind( d1, d2, m ) @ #i)
 ∧
  (∀ #j. (!KU( m ) @ #j) ⇒ ¬(#j < #i)) ∧
  (∀ s #j. (Secrets( m, s ) @ #j) ⇒ ⊥) ∧
  (∀ s #j. (Secrets( s, m ) @ #j) ⇒ ⊥)"
*/
induction
  case empty_trace
  by contradiction // from formulas
next
  case non_empty_trace
  simplify
  solve( (last(#i))  ∥
         (∃ #j. (!KU( m ) @ #j) ∧ (¬(last(#j))) ∧ (#j < #i))  ∥
         (∃ s #j. (Secrets( m, s ) @ #j) ∧ ¬(last(#j)))  ∥
         (∃ s #j. (Secrets( s, m ) @ #j) ∧ ¬(last(#j))) )
    case case_1
    solve( !KeyTable( d1, d2 ) ▶₁ #i )
      case MkKey
      solve( !KU( aenc(m, pk(~ska)) ) @ #vk )
        case Alice_Init_case_1
        by contradiction // from formulas
      next
        case Alice_Init_case_2
        by contradiction // from formulas
      next
        case PCR_Unbind
        solve( (∃ #j. (!KU( t ) @ #j) ∧ (¬(last(#j))) ∧ (#j < #vr.1))  ∥
               (∃ s #j. (Secrets( t, s ) @ #j) ∧ ¬(last(#j)))  ∥
               (∃ s #j. (Secrets( s, t ) @ #j) ∧ ¬(last(#j))) )
          case case_1
          by contradiction // cyclic
        next
          case case_2
          by solve( (#vl, 0) ~~> (#vk, 0) )
        next
          case case_3
          by solve( (#vl, 0) ~~> (#vk, 0) )
        qed
      next
        case caenc
        by contradiction // from formulas
      qed
    qed
  next
    case case_2
    by contradiction // from formulas
  next
    case case_3
    by contradiction // from formulas
  next
    case case_4
    by contradiction // from formulas
  qed
qed

lemma Unbind_PCR_Value [reuse, use_induction]:
  all-traces
  "∀ x sk m #i.
    (PCR_Unbind( x, sk, m ) @ #i) ⇒
    (((∃ aik #j. PCR_Init( x, aik ) @ #j) ∨
      (∃ y xPrev #j. PCR_Extend( xPrev, y, x ) @ #j)) ∨
     (∃ #i.1 #j.
       ((UniqueInit( ) @ #j) ∧ (UniqueInit( ) @ #i.1)) ∧ (¬(#i.1 = #j))))"
/*
guarded formula characterizing all counter-examples:
"∃ x sk m #i.
  (PCR_Unbind( x, sk, m ) @ #i)
 ∧
  (∀ aik #j. (PCR_Init( x, aik ) @ #j) ⇒ ⊥) ∧
  (∀ y xPrev #j. (PCR_Extend( xPrev, y, x ) @ #j) ⇒ ⊥) ∧
  (∀ #i.1 #j. (UniqueInit( ) @ #j) ∧ (UniqueInit( ) @ #i.1) ⇒ #i.1 = #j)"
*/
induction
  case empty_trace
  by contradiction // from formulas
next
  case non_empty_trace
  simplify
  solve( (last(#i))  ∥
         (∃ aik #j. (PCR_Init( x, aik ) @ #j) ∧ ¬(last(#j)))  ∥
         (∃ y xPrev #j. (PCR_Extend( xPrev, y, x ) @ #j) ∧ ¬(last(#j)))  ∥
         (∃ #i #j.
           (UniqueInit( ) @ #j) ∧ (UniqueInit( ) @ #i)
          ∧
           (¬(last(#j))) ∧ (¬(last(#i))) ∧ (¬(#i = #j))) )
    case case_1
    solve( !KeyTable( x, sk ) ▶₁ #i )
      case MkKey
      solve( !KU( aenc(m, pk(~ska)) ) @ #vk )
        case Alice_Init_case_1
        solve( !KU( sign(<'certkey', x0, pk(~ska)>, ~aik) ) @ #vk.1 )
          case PCR_CertKey
          solve( !KU( sign(<'certkey', x1, pk1>, ~aik) ) @ #vk.2 )
            case PCR_CertKey
            solve( PCR( h(<'pcr0', $a>) ) ▶₀ #i )
              case PCR_Extend
              by contradiction // from formulas
            next
              case PCR_Unbind
              solve( (∃ aik #j.
                       (PCR_Init( h(<'pcr0', $a>), aik ) @ #j) ∧ ¬(last(#j)))  ∥
                     (∃ y xPrev #j.
                       (PCR_Extend( xPrev, y, h(<'pcr0', $a>) ) @ #j) ∧ ¬(last(#j)))  ∥
                     (∃ #i #j.
                       (UniqueInit( ) @ #j) ∧ (UniqueInit( ) @ #i)
                      ∧
                       (¬(last(#j))) ∧ (¬(last(#i))) ∧ (¬(#i = #j))) )
                case case_2
                by contradiction // from formulas
              next
                case case_3
                by contradiction // from formulas
              qed
            qed
          next
            case csign
            by solve( !KU( ~aik ) @ #vk.4 )
          qed
        next
          case csign
          by solve( !KU( ~aik ) @ #vk.4 )
        qed
      next
        case Alice_Init_case_2
        solve( !KU( sign(<'certkey', x0, pk0>, ~aik) ) @ #vk.1 )
          case PCR_CertKey
          solve( !KU( sign(<'certkey', x1, pk(~ska)>, ~aik) ) @ #vk.2 )
            case PCR_CertKey
            solve( PCR( h(<'pcr0', $a>) ) ▶₀ #i )
              case PCR_Extend
              by contradiction // from formulas
            next
              case PCR_Unbind
              solve( (∃ aik #j.
                       (PCR_Init( h(<'pcr0', $a>), aik ) @ #j) ∧ ¬(last(#j)))  ∥
                     (∃ y xPrev #j.
                       (PCR_Extend( xPrev, y, h(<'pcr0', $a>) ) @ #j) ∧ ¬(last(#j)))  ∥
                     (∃ #i #j.
                       (UniqueInit( ) @ #j) ∧ (UniqueInit( ) @ #i)
                      ∧
                       (¬(last(#j))) ∧ (¬(last(#i))) ∧ (¬(#i = #j))) )
                case case_2
                by contradiction // from formulas
              next
                case case_3
                by contradiction // from formulas
              qed
            qed
          next
            case csign
            by solve( !KU( ~aik ) @ #vk.4 )
          qed
        next
          case csign
          by solve( !KU( ~aik ) @ #vk.4 )
        qed
      next
        case caenc
        solve( !KU( pk(~ska) ) @ #vk.2 )
          case cpk
          by solve( !KU( ~ska ) @ #vk.3 )
        qed
      qed
    qed
  next
    case case_2
    by contradiction // from formulas
  next
    case case_3
    by contradiction // from formulas
  next
    case case_4
    by contradiction // from formulas
  qed
qed

lemma secrecy:
  all-traces
  "((∀ #i #j. ((UniqueInit( ) @ #j) ∧ (UniqueInit( ) @ #i)) ⇒ (#i = #j)) ∧
    (∀ t #e. (Ineq( t, t ) @ #e) ⇒ (⊥))) ⇒
   (¬(∃ s0 s1 #i #d0 #d1.
       ((Secrets( s0, s1 ) @ #i) ∧ (K( s0 ) @ #d0)) ∧ (K( s1 ) @ #d1)))"
/*
guarded formula characterizing all counter-examples:
"(∀ #i #j. (UniqueInit( ) @ #j) ∧ (UniqueInit( ) @ #i) ⇒ #i = #j) ∧
 (∀ t #e. (Ineq( t, t ) @ #e) ⇒ ⊥) ∧
 (∃ s0 s1 #i #d0 #d1.
   (Secrets( s0, s1 ) @ #i) ∧ (K( s0 ) @ #d0) ∧ (K( s1 ) @ #d1))"
*/
simplify
solve( !AIK( aik ) ▶₂ #i )
  case PCR_Init
  solve( !KU( ~s0 ) @ #vk.2 )
    case Alice_Init
    solve( !KU( ~s1 ) @ #vk.3 )
      case Alice_Init
      solve( !KU( sign(<'certkey', x0, pk(x)>, ~aik) ) @ #vk.2 )
        case PCR_CertKey
        by solve( !KU( ~ska ) @ #vk.4 )
      next
        case csign
        by solve( !KU( ~aik ) @ #vk.7 )
      qed
    next
      case PCR_Unbind
      solve( (∃ aik #j. (PCR_Init( h(<'pcr0', $a>), aik ) @ #j))  ∥
             (∃ y xPrev #j. (PCR_Extend( xPrev, y, h(<'pcr0', $a>) ) @ #j))  ∥
             (∃ #i #j. (UniqueInit( ) @ #j) ∧ (UniqueInit( ) @ #i) ∧ ¬(#i = #j)) )
        case case_2
        solve( !KU( sign(<'certkey', x0, pk(x)>, ~aik) ) @ #vk.2 )
          case PCR_CertKey
          by solve( !KU( ~ska ) @ #vk.4 )
        next
          case csign
          by solve( !KU( ~aik ) @ #vk.8 )
        qed
      next
        case case_3
        by contradiction // from formulas
      qed
    qed
  next
    case PCR_Unbind
    solve( (∃ aik #j. (PCR_Init( h(<'pcr0', $a>), aik ) @ #j))  ∥
           (∃ y xPrev #j. (PCR_Extend( xPrev, y, h(<'pcr0', $a>) ) @ #j))  ∥
           (∃ #i #j. (UniqueInit( ) @ #j) ∧ (UniqueInit( ) @ #i) ∧ ¬(#i = #j)) )
      case case_2
      solve( !KU( ~s1 ) @ #vk.3 )
        case Alice_Init
        solve( !KU( sign(<'certkey', x0, pk0>, ~aik) ) @ #vk.2 )
          case PCR_CertKey
          solve( !KU( sign(<'certkey', x1, pk(x)>, ~aik) ) @ #vk.3 )
            case PCR_CertKey
            by solve( !KU( ~ska.1 ) @ #vk.6 )
          next
            case csign
            by solve( !KU( ~aik ) @ #vk.8 )
          qed
        next
          case csign
          by solve( !KU( ~aik ) @ #vk.8 )
        qed
      next
        case PCR_Unbind
        solve( (∃ aik #j. (PCR_Init( h(<'pcr0', $a.1>), aik ) @ #j))  ∥
               (∃ y xPrev #j. (PCR_Extend( xPrev, y, h(<'pcr0', $a.1>) ) @ #j))  ∥
               (∃ #i #j. (UniqueInit( ) @ #j) ∧ (UniqueInit( ) @ #i) ∧ ¬(#i = #j)) )
          case case_2
          solve( !KU( sign(<'certkey', x0, pk0>, ~aik) ) @ #vk.2 )
            case PCR_CertKey
            solve( !KU( sign(<'certkey', x1, pk1>, ~aik) ) @ #vk.3 )
              case PCR_CertKey
              solve( !KU( aenc(~s0, pk(~ska.2)) ) @ #vk.4 )
                case Alice_Init
                solve( !KU( aenc(~s1, pk(~ska.2)) ) @ #vk.6 )
                  case Alice_Init
                  solve( PCR( h(<'pcr0', $a>) ) ▶₀ #vr.1 )
                    case PCR_Extend
                    solve( PCR( 'pcr0' ) ▶₀ #j )
                      case PCR_Init
                      solve( PCR( h(<'pcr0', $a.1>) ) ▶₀ #vr.3 )
                        case PCR_Extend
                        solve( PCR( 'pcr0' ) ▶₀ #j.1 )
                          case PCR_Init
                          by contradiction // from formulas
                        qed
                      next
                        case PCR_Unbind
                        solve( !KU( aenc(m, pk(~ska.2)) ) @ #vk.8 )
                          case Alice_Init_case_1
                          solve( !KU( sign(<'certkey', x0, pk(~ska.2)>, ~aik) ) @ #vk.9 )
                            case PCR_CertKey
                            solve( !KU( sign(<'certkey', x1, pk1>, ~aik) ) @ #vk.10 )
                              case PCR_CertKey
                              solve( PCR( 'pcr0' ) ▶₀ #j.1 )
                                case PCR_Init
                                by contradiction // from formulas
                              qed
                            next
                              case csign
                              by solve( !KU( ~aik ) @ #vk.12 )
                            qed
                          next
                            case csign
                            by solve( !KU( ~aik ) @ #vk.12 )
                          qed
                        next
                          case Alice_Init_case_2
                          solve( !KU( sign(<'certkey', x0, pk0>, ~aik) ) @ #vk.9 )
                            case PCR_CertKey
                            solve( !KU( sign(<'certkey', x1, pk(~ska.2)>, ~aik) ) @ #vk.10 )
                              case PCR_CertKey
                              solve( PCR( 'pcr0' ) ▶₀ #j.1 )
                                case PCR_Init
                                by contradiction // from formulas
                              qed
                            next
                              case csign
                              by solve( !KU( ~aik ) @ #vk.12 )
                            qed
                          next
                            case csign
                            by solve( !KU( ~aik ) @ #vk.12 )
                          qed
                        next
                          case caenc
                          solve( !KU( pk(~ska.2) ) @ #vk.10 )
                            case cpk
                            by solve( !KU( ~ska.2 ) @ #vk.11 )
                          qed
                        qed
                      qed
                    qed
                  next
                    case PCR_Unbind
                    solve( !KU( aenc(m, pk(~ska.2)) ) @ #vk.8 )
                      case Alice_Init_case_1
                      solve( !KU( sign(<'certkey', x0, pk(~ska.2)>, ~aik) ) @ #vk.9 )
                        case PCR_CertKey
                        solve( !KU( sign(<'certkey', x1, pk1>, ~aik) ) @ #vk.10 )
                          case PCR_CertKey
                          solve( PCR( 'pcr0' ) ▶₀ #j )
                            case PCR_Init
                            solve( PCR( h(<'pcr0', $a.1>) ) ▶₀ #vr.3 )
                              case PCR_Extend
                              solve( PCR( 'pcr0' ) ▶₀ #j.1 )
                                case PCR_Init
                                by contradiction // from formulas
                              qed
                            next
                              case PCR_Unbind
                              solve( !KU( aenc(m, pk(~ska.4)) ) @ #vk.11 )
                                case Alice_Init_case_1
                                solve( !KU( sign(<'certkey', x0, pk(~ska.4)>, ~aik) ) @ #vk.12 )
                                  case PCR_CertKey
                                  solve( !KU( sign(<'certkey', x1, pk1>, ~aik) ) @ #vk.13 )
                                    case PCR_CertKey
                                    solve( PCR( 'pcr0' ) ▶₀ #j.1 )
                                      case PCR_Init
                                      by contradiction // from formulas
                                    qed
                                  next
                                    case csign
                                    by solve( !KU( ~aik ) @ #vk.15 )
                                  qed
                                next
                                  case csign
                                  by solve( !KU( ~aik ) @ #vk.15 )
                                qed
                              next
                                case Alice_Init_case_2
                                solve( !KU( sign(<'certkey', x0, pk0>, ~aik) ) @ #vk.12 )
                                  case PCR_CertKey
                                  solve( !KU( sign(<'certkey', x1, pk(~ska.4)>, ~aik) ) @ #vk.13 )
                                    case PCR_CertKey
                                    solve( PCR( 'pcr0' ) ▶₀ #j.1 )
                                      case PCR_Init
                                      by contradiction // from formulas
                                    qed
                                  next
                                    case csign
                                    by solve( !KU( ~aik ) @ #vk.15 )
                                  qed
                                next
                                  case csign
                                  by solve( !KU( ~aik ) @ #vk.15 )
                                qed
                              next
                                case caenc
                                solve( !KU( pk(~ska.4) ) @ #vk.13 )
                                  case cpk
                                  by solve( !KU( ~ska.4 ) @ #vk.14 )
                                qed
                              qed
                            qed
                          qed
                        next
                          case csign
                          by solve( !KU( ~aik ) @ #vk.12 )
                        qed
                      next
                        case csign
                        by solve( !KU( ~aik ) @ #vk.12 )
                      qed
                    next
                      case Alice_Init_case_2
                      solve( !KU( sign(<'certkey', x0, pk0>, ~aik) ) @ #vk.9 )
                        case PCR_CertKey
                        solve( !KU( sign(<'certkey', x1, pk(~ska.2)>, ~aik) ) @ #vk.10 )
                          case PCR_CertKey
                          solve( PCR( 'pcr0' ) ▶₀ #j )
                            case PCR_Init
                            solve( PCR( h(<'pcr0', $a.1>) ) ▶₀ #vr.3 )
                              case PCR_Extend
                              solve( PCR( 'pcr0' ) ▶₀ #j.1 )
                                case PCR_Init
                                by contradiction // from formulas
                              qed
                            next
                              case PCR_Unbind
                              solve( !KU( aenc(m, pk(~ska.4)) ) @ #vk.11 )
                                case Alice_Init_case_1
                                solve( !KU( sign(<'certkey', x0, pk(~ska.4)>, ~aik) ) @ #vk.12 )
                                  case PCR_CertKey
                                  solve( !KU( sign(<'certkey', x1, pk1>, ~aik) ) @ #vk.13 )
                                    case PCR_CertKey
                                    solve( PCR( 'pcr0' ) ▶₀ #j.1 )
                                      case PCR_Init
                                      by contradiction // from formulas
                                    qed
                                  next
                                    case csign
                                    by solve( !KU( ~aik ) @ #vk.15 )
                                  qed
                                next
                                  case csign
                                  by solve( !KU( ~aik ) @ #vk.15 )
                                qed
                              next
                                case Alice_Init_case_2
                                solve( !KU( sign(<'certkey', x0, pk0>, ~aik) ) @ #vk.12 )
                                  case PCR_CertKey
                                  solve( !KU( sign(<'certkey', x1, pk(~ska.4)>, ~aik) ) @ #vk.13 )
                                    case PCR_CertKey
                                    solve( PCR( 'pcr0' ) ▶₀ #j.1 )
                                      case PCR_Init
                                      by contradiction // from formulas
                                    qed
                                  next
                                    case csign
                                    by solve( !KU( ~aik ) @ #vk.15 )
                                  qed
                                next
                                  case csign
                                  by solve( !KU( ~aik ) @ #vk.15 )
                                qed
                              next
                                case caenc
                                solve( !KU( pk(~ska.4) ) @ #vk.13 )
                                  case cpk
                                  by solve( !KU( ~ska.4 ) @ #vk.14 )
                                qed
                              qed
                            qed
                          qed
                        next
                          case csign
                          by solve( !KU( ~aik ) @ #vk.12 )
                        qed
                      next
                        case csign
                        by solve( !KU( ~aik ) @ #vk.12 )
                      qed
                    next
                      case caenc
                      solve( !KU( pk(~ska.2) ) @ #vk.10 )
                        case cpk
                        by solve( !KU( ~ska.2 ) @ #vk.11 )
                      qed
                    qed
                  qed
                next
                  case caenc
                  by contradiction // cyclic
                qed
              next
                case caenc
                by contradiction // cyclic
              qed
            next
              case csign
              by solve( !KU( ~aik ) @ #vk.9 )
            qed
          next
            case csign
            by solve( !KU( ~aik ) @ #vk.9 )
          qed
        next
          case case_3
          by contradiction // from formulas
        qed
      qed
    next
      case case_3
      by contradiction // from formulas
    qed
  qed
qed

/* All well-formedness checks were successful. */

end
/* Output
maude tool: 'maude'
 checking version: 2.6. OK.
 checking installation: OK.


analyzing: data/examples/related_work/TPM_DKRS_CSF11/RunningExample.spthy

------------------------------------------------------------------------------
analyzed: data/examples/related_work/TPM_DKRS_CSF11/RunningExample.spthy

  output:          case-studies/temp-analysis.spthy
  processing time: 1.561274s
  types (all-traces): verified (16 steps)
  Unbind_PCR_Value (all-traces): verified (29 steps)
  secrecy (all-traces): verified (99 steps)

------------------------------------------------------------------------------

==============================================================================
summary of summaries:

analyzed: data/examples/related_work/TPM_DKRS_CSF11/RunningExample.spthy

  output:          case-studies/temp-analysis.spthy
  processing time: 1.561274s
  types (all-traces): verified (16 steps)
  Unbind_PCR_Value (all-traces): verified (29 steps)
  secrecy (all-traces): verified (99 steps)

==============================================================================
*/
