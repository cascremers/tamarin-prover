theory Keyserver begin

// Function signature and definition of the equational theory E

functions: fst/1, pair/2, pk/1, sign/2, snd/1, true/0, verify/3
equations:
    fst(<x.1, x.2>) = x.1,
    snd(<x.1, x.2>) = x.2,
    verify(sign(x.1, x.2), x.1, pk(x.2)) = true()

rule (modulo E) SetupHonestKey:
   [ Fr( ~sk ) ]
  --[ HonestKey( ~sk ) ]->
   [ Out( pk(~sk) ), ClientKey( $A, ~sk ), ServerDB( $A, ~sk ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) SetupDishonestKey:
   [ In( sk ) ] --> [ ServerDB( $A, sk ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) RequestRenewKey:
   [ ClientKey( $A, sk ), Fr( ~skNew ) ]
  --[ HonestKey( ~skNew ) ]->
   [ Out( sign(<'renew', $A, pk(~skNew)>, sk) ), ClientKey( $A, ~skNew ) ]

  // loop breaker: [0]
  /* has exactly the trivial AC variant */

rule (modulo E) RenewKey:
   [ In( sign(<'renew', A, pk(skNew)>, sk) ), ServerDB( A, sk ) ]
  --[ Revoked( sk ) ]->
   [ ServerDB( A, skNew ), Out( sk ) ]

  // loop breaker: [1]
  /* has exactly the trivial AC variant */

lemma types [typing]:
  all-traces
  "∀ sk #i.
    (Revoked( sk ) @ #i) ⇒
    ((∃ #j. (!KU( sk ) @ #j) ∧ (#j < #i)) ∨
     (∃ #j. (HonestKey( sk ) @ #j) ∧ (#j < #i)))"
/*
guarded formula characterizing all counter-examples:
"∃ sk #i.
  (Revoked( sk ) @ #i)
 ∧
  (∀ #j. (!KU( sk ) @ #j) ⇒ ¬(#j < #i)) ∧
  (∀ #j. (HonestKey( sk ) @ #j) ⇒ ¬(#j < #i))"
*/
induction
  case empty_trace
  by contradiction // from formulas
next
  case non_empty_trace
  simplify
  solve( (last(#i))  ∥
         (∃ #j. (!KU( sk ) @ #j) ∧ (¬(last(#j))) ∧ (#j < #i))  ∥
         (∃ #j. (HonestKey( sk ) @ #j) ∧ (¬(last(#j))) ∧ (#j < #i)) )
    case case_1
    solve( !KU( sign(<'renew', A, pk(skNew)>, sk) ) @ #vk )
      case RenewKey
      solve( (∃ #j. (!KU( t ) @ #j) ∧ (¬(last(#j))) ∧ (#j < #vr))  ∥
             (∃ #j. (HonestKey( t ) @ #j) ∧ (¬(last(#j))) ∧ (#j < #vr)) )
        case case_1
        by contradiction // cyclic
      next
        case case_2
        solve( HonestKey( t ) @ #j )
          case RequestRenewKey
          by solve( (#vl, 0) ~~> (#vk, 0) )
        next
          case SetupHonestKey
          by solve( (#vl, 0) ~~> (#vk, 0) )
        qed
      qed
    next
      case RequestRenewKey
      solve( ServerDB( $A, sk ) ▶₁ #i )
        case RenewKey
        solve( (∃ #j. (!KU( sk.1 ) @ #j) ∧ (¬(last(#j))) ∧ (#j < #vr.1))  ∥
               (∃ #j. (HonestKey( sk.1 ) @ #j) ∧ (¬(last(#j))) ∧ (#j < #vr.1)) )
          case case_1
          solve( !KU( sign(<'renew', $A, pk(sk)>, sk.1) ) @ #vk.1 )
            case RenewKey
            solve( (∃ #j. (!KU( t ) @ #j) ∧ (¬(last(#j))) ∧ (#j < #vr.2))  ∥
                   (∃ #j. (HonestKey( t ) @ #j) ∧ (¬(last(#j))) ∧ (#j < #vr.2)) )
              case case_1
              by contradiction // cyclic
            next
              case case_2
              solve( HonestKey( t ) @ #j.1 )
                case RequestRenewKey
                by solve( (#vl.1, 0) ~~> (#vk.1, 0) )
              next
                case SetupHonestKey
                by solve( (#vl.1, 0) ~~> (#vk.1, 0) )
              qed
            qed
          next
            case RequestRenewKey
            by contradiction // from formulas
          next
            case csign
            solve( !KU( pk(sk) ) @ #vk.6 )
              case RenewKey
              solve( (∃ #j. (!KU( t ) @ #j) ∧ (¬(last(#j))) ∧ (#j < #vr.2))  ∥
                     (∃ #j. (HonestKey( t ) @ #j) ∧ (¬(last(#j))) ∧ (#j < #vr.2)) )
                case case_1
                by contradiction // cyclic
              next
                case case_2
                solve( HonestKey( t ) @ #j.1 )
                  case RequestRenewKey
                  by solve( (#vl.1, 0) ~~> (#vk.2, 0) )
                next
                  case SetupHonestKey
                  by solve( (#vl.1, 0) ~~> (#vk.2, 0) )
                qed
              qed
            next
              case SetupHonestKey
              by contradiction // from formulas
            next
              case cpk
              by contradiction // from formulas
            qed
          qed
        next
          case case_2
          solve( HonestKey( sk.1 ) @ #j )
            case RequestRenewKey
            solve( !KU( sign(<'renew', $A, pk(sk)>, ~skNew.1) ) @ #vk.1 )
              case RenewKey
              solve( (∃ #j. (!KU( t ) @ #j) ∧ (¬(last(#j))) ∧ (#j < #vr.2))  ∥
                     (∃ #j. (HonestKey( t ) @ #j) ∧ (¬(last(#j))) ∧ (#j < #vr.2)) )
                case case_1
                by contradiction // cyclic
              next
                case case_2
                solve( HonestKey( t ) @ #j.1 )
                  case RequestRenewKey
                  by solve( (#vl.1, 0) ~~> (#vk.1, 0) )
                next
                  case SetupHonestKey
                  by solve( (#vl.1, 0) ~~> (#vk.1, 0) )
                qed
              qed
            next
              case RequestRenewKey
              by contradiction // from formulas
            next
              case csign
              solve( !KU( ~skNew.1 ) @ #vk.3 )
                case RenewKey
                solve( (∃ #j. (!KU( t ) @ #j) ∧ (¬(last(#j))) ∧ (#j < #vr.2))  ∥
                       (∃ #j. (HonestKey( t ) @ #j) ∧ (¬(last(#j))) ∧ (#j < #vr.2)) )
                  case case_1
                  by contradiction // cyclic
                next
                  case case_2
                  solve( HonestKey( t ) @ #j.1 )
                    case RequestRenewKey
                    solve( (#vl.1, 0) ~~> (#vk.2, 0) )
                      case ~skNew.2
                      solve( !KU( pk(sk) ) @ #vk.7 )
                        case RenewKey
                        solve( (∃ #j. (!KU( t ) @ #j) ∧ (¬(last(#j))) ∧ (#j < #vr.3))  ∥
                               (∃ #j. (HonestKey( t ) @ #j) ∧ (¬(last(#j))) ∧ (#j < #vr.3)) )
                          case case_1
                          by contradiction // cyclic
                        next
                          case case_2
                          solve( HonestKey( t ) @ #j.1 )
                            case RequestRenewKey
                            by solve( (#vl.2, 0) ~~> (#vk.3, 0) )
                          next
                            case SetupHonestKey
                            by solve( (#vl.2, 0) ~~> (#vk.3, 0) )
                          qed
                        qed
                      next
                        case SetupHonestKey
                        by contradiction // from formulas
                      next
                        case cpk
                        by contradiction // from formulas
                      qed
                    qed
                  next
                    case SetupHonestKey
                    by solve( (#vl.1, 0) ~~> (#vk.2, 0) )
                  qed
                qed
              qed
            qed
          next
            case SetupHonestKey
            solve( !KU( sign(<'renew', $A, pk(sk)>, ~sk.1) ) @ #vk.1 )
              case RenewKey
              solve( (∃ #j. (!KU( t ) @ #j) ∧ (¬(last(#j))) ∧ (#j < #vr.2))  ∥
                     (∃ #j. (HonestKey( t ) @ #j) ∧ (¬(last(#j))) ∧ (#j < #vr.2)) )
                case case_1
                by contradiction // cyclic
              next
                case case_2
                solve( HonestKey( t ) @ #j.1 )
                  case RequestRenewKey
                  by solve( (#vl.1, 0) ~~> (#vk.1, 0) )
                next
                  case SetupHonestKey
                  by solve( (#vl.1, 0) ~~> (#vk.1, 0) )
                qed
              qed
            next
              case RequestRenewKey
              by contradiction // from formulas
            next
              case csign
              solve( !KU( ~sk.1 ) @ #vk.3 )
                case RenewKey
                solve( (∃ #j. (!KU( t ) @ #j) ∧ (¬(last(#j))) ∧ (#j < #vr.2))  ∥
                       (∃ #j. (HonestKey( t ) @ #j) ∧ (¬(last(#j))) ∧ (#j < #vr.2)) )
                  case case_1
                  by contradiction // cyclic
                next
                  case case_2
                  solve( HonestKey( t ) @ #j.1 )
                    case RequestRenewKey
                    by solve( (#vl.1, 0) ~~> (#vk.2, 0) )
                  next
                    case SetupHonestKey
                    solve( (#vl.1, 0) ~~> (#vk.2, 0) )
                      case ~sk.2
                      solve( !KU( pk(sk) ) @ #vk.7 )
                        case RenewKey
                        solve( (∃ #j. (!KU( t ) @ #j) ∧ (¬(last(#j))) ∧ (#j < #vr.3))  ∥
                               (∃ #j. (HonestKey( t ) @ #j) ∧ (¬(last(#j))) ∧ (#j < #vr.3)) )
                          case case_1
                          by contradiction // cyclic
                        next
                          case case_2
                          solve( HonestKey( t ) @ #j.1 )
                            case RequestRenewKey
                            by solve( (#vl.2, 0) ~~> (#vk.3, 0) )
                          next
                            case SetupHonestKey
                            by solve( (#vl.2, 0) ~~> (#vk.3, 0) )
                          qed
                        qed
                      next
                        case SetupHonestKey
                        by contradiction // from formulas
                      next
                        case cpk
                        by contradiction // from formulas
                      qed
                    qed
                  qed
                qed
              qed
            qed
          qed
        qed
      next
        case SetupDishonestKey
        by contradiction // from formulas
      next
        case SetupHonestKey
        by contradiction // from formulas
      qed
    next
      case csign
      by contradiction // from formulas
    qed
  next
    case case_2
    by contradiction // from formulas
  next
    case case_3
    by contradiction // from formulas
  qed
qed

lemma In_Honest_Key_imp_Revoked:
  all-traces
  "∀ sk #i #d.
    ((HonestKey( sk ) @ #i) ∧ (K( sk ) @ #d)) ⇒ (∃ #r. Revoked( sk ) @ #r)"
/*
guarded formula characterizing all counter-examples:
"∃ sk #i #d.
  (HonestKey( sk ) @ #i) ∧ (K( sk ) @ #d) ∧ ∀ #r. (Revoked( sk ) @ #r) ⇒ ⊥"
*/
simplify
solve( HonestKey( sk ) @ #i )
  case RequestRenewKey
  solve( !KU( ~skNew ) @ #vk )
    case RenewKey
    by contradiction // from formulas
  qed
next
  case SetupHonestKey
  solve( !KU( ~sk ) @ #vk )
    case RenewKey
    by contradiction // from formulas
  qed
qed

/* All well-formedness checks were successful. */

end
/* Output
maude tool: 'maude'
 checking version: 2.6. OK.
 checking installation: OK.


analyzing: data/examples/related_work/AIF_Moedersheim_CCS10/Keyserver.spthy

------------------------------------------------------------------------------
analyzed: data/examples/related_work/AIF_Moedersheim_CCS10/Keyserver.spthy

  output:          case-studies/temp-analysis.spthy
  processing time: 0.436344s
  types (all-traces): verified (75 steps)
  In_Honest_Key_imp_Revoked (all-traces): verified (6 steps)

------------------------------------------------------------------------------

==============================================================================
summary of summaries:

analyzed: data/examples/related_work/AIF_Moedersheim_CCS10/Keyserver.spthy

  output:          case-studies/temp-analysis.spthy
  processing time: 0.436344s
  types (all-traces): verified (75 steps)
  In_Honest_Key_imp_Revoked (all-traces): verified (6 steps)

==============================================================================
*/
