theory RYY
begin

builtins: bilinear-pairing

functions: kdf/1, hp/1

section{* RYY : UM-like identity based key exchange protocol *}

/*
 * Protocol:	RYY
 * Modeler: 	Benedikt Schmidt
 * Date: 	July 2012
 * Source:	Boyd overview identity based key exchange protocols
 *
 * Status: 	Working
 */


// Key generation center

rule KGC_Setup:
  [ Fr(msk) ]
  -->
  [ !MSK( msk ) ]

rule KGC_request:
  [ !MSK( s ) ]
  -->
  [ !LTK( $ID, pmult(s, hp($ID)) ) ]


// Reveals

rule Reveal_ltk:
  [ !LTK( $ID, skID ) ]
  --[ LtkRev($ID) ]->
  [ Out(skID) ]

rule Reveal_master_key:
  [ !MSK( msk ) ]
  --[ MskRev() ]->
  [ Out( msk ) ]

rule Reveal_session_key:
  [ !Sessk( ~ey, sek ) ]
  --[ SesskRev( ~ey ) ]->
  [ Out( sek ) ]


// Protocol

rule Init_1:
  [ Fr( ~ex ) ]
  -->
  [ Init( ~ex, $A, $B )
  , Out( 'g'^~ex )
  ]

rule Init_2:
  let X = 'g'^~ex
      sessKey = kdf( Y^~ex, em(hp($B), skA), $A, $B, X, Y )
  in
  [ Init( ~ex, $A, $B )
  , !LTK( $A, skA )
  , In( Y )
  ]
  --[ Accept( ~ex, $A, $B, sessKey )
    , Sid( ~ex, <'Init',$A,$B,X,Y> )
    // a matching session for ~ex has the following sid
    , Match( ~ex, <'Resp',$B,$A,X,Y> )
    ]->
  []


rule Resp_1:
  let Y = 'g'^~ey
      sessKey = kdf(X^~ey, em(skB, hp($A)), $A, $B, X, Y)
  in
  [ Fr( ~ey )
  , !LTK( $B, skB )
  , In( X )
  ]
  --[ Accept( ~ey, $B, $A, sessKey )
    , Sid( ~ey, <'Resp',$B,$A,X,Y> )
    // a matching session for ~ey has the following sid
    , Match( ~ey, <'Init',$A,$B,X,Y> )
    ]->
  [ Out( Y )
  , !Sessk( ~ey, sessKey )
  ]

/*
lemma key_agreement_reachable:
  exists-trace
  "Ex #i #j A B SID t1 t2 k.
        Accept(t1, A, B, k) @ i
      & Match(t1,  SID) @ i
      & Accept(t2, B, A, k) @ j
      & Sid(t2, SID) @ j"
*/

lemma key_secrecy_WPFS:
  /* 
   * We do not consider ephemeral key reveals for RYY
   * 
   * If there exists a Test session whose key k is known to the
   * Adversary, then...
   */
  "(All #i1 #i2 test A B k.
    Accept(test, A, B, k) @ i1 & K( k ) @ i2
    ==> ( 
    // ... the test session must be "not clean".
    // test is not clean if one of the following has happened:
    //
    // session-key-reveal of test thread.
      (Ex #i3. SesskRev( test ) @ i3 )

    // there is a matching session
    | (Ex matching #i3 #i4 sid.
    	   // matching's 'sid' info matches with test
           ( Sid ( matching, sid ) @ i3 & Match( test, sid ) @ i4)
	   & ( 
             // matching's session key was revealed
	       (Ex #i5. SesskRev( matching ) @ i5 )

             // matching's longterm key was revealed before test was finished
             // (we assume matching session ensures that matching.actor = test.peer)
             | (Ex #i5. LtkRev( B ) @ i5 & i5 < i1)

             // the longterm key of the test session was revealed before test was finished
             | (Ex #i5. LtkRev( A ) @ i5 & i5 < i1 )

             // the master key was revealed before test was finished
             | (Ex #i5. MskRev() @ i5 & i5 < i1 )
	   )
      )

    // there is no matching session
    | (  (not (Ex matching #i3 #i4 sid.
    	   // matching's 'sid' info matches with test
           ( Sid ( matching, sid ) @ i3 & Match( test, sid ) @ i4)))

        & (  
          // the longterm key of test.peer was revealed
            (Ex #i5. LtkRev( B ) @ i5 )

          // the longterm key of test.actor was revealed
          | (Ex #i3. LtkRev(A) @ i3 )
          
          // the master key was revealed
          | (Ex #i3. MskRev() @ i3)
          )
      )

    )
  )"

end